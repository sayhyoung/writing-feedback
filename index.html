<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Writing Feedback</title>
  <style>
    body { font-family: sans-serif; max-width: 600px; margin: 2rem auto; padding: 1rem; }
    label { display: block; margin: 0.5rem 0; }
    textarea, input[type="text"], select, input[type="file"] {
      width: 100%; padding: 0.5rem; margin-top: 0.25rem;
    }
    button {
      position: relative;
      margin-top: 1rem;
      padding: 0.75rem 1.5rem;
      /* Add min-width to prevent button collapsing when text is replaced by spinner */
      min-width: 80px; /* Adjust as needed */
    }
    /* Style for the button text when spinner is shown */
    button .button-text {
        display: inline-block;
        vertical-align: middle;
    }

    /* red CSS spinner */
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .spinner {
      display: none; /* Initially hidden */
      border: 2px solid #f3f3f3; /* Light grey */
      border-top: 2px solid #3498db; /* Blue */
      border-radius: 50%;
      width: 16px;
      height: 16px;
      animation: spin 1s linear infinite;
      vertical-align: middle;
      margin-left: 0.5rem;
      /* Position the spinner if needed, or just use margin */
    }
    /* Show spinner and hide text when button is disabled and spinner is active */
    button:disabled .spinner {
        display: inline-block;
    }
     button:disabled .button-text {
        /* Optionally hide text or use visibility */
        /* visibility: hidden; */
        /* opacity: 0; */
     }


    .box { border: 1px solid #ccc; padding: 1rem; margin-top: 1rem; }
    .model-box { text-align: left; font-size: 1em; line-height: 1.5; } /* Adjusted text-align and font size */
    .model-box h3 { text-align: center; margin-top: 0; } /* Center model answer title */

    @media print {
      #submit-btn, #tts-btn, #print-btn { display: none !important; }
    }
  </style>
</head>
<body>
  <h1>Writing Feedback</h1>
  <form id="feedback-form">
    <label>Topic/Title (optional)
      <input type="text" id="topic" placeholder="Enter topic or leave blank" name="topic" />
    </label>
    <label>Keywords (optional)
      <input type="text" id="keywords" placeholder="Comma-separated keywords" name="keywords" />
    </label>
    <label>Text Content (optional)
      <textarea id="contentText" rows="8" placeholder="Paste your writing here" name="contentText"></textarea> {/* Increased rows */}
    </label>
    {/* Image Upload is more complex with Worker. Omitting for simplicity in this fix */}
    {/*
    <label>Image Upload (optional)
      <input type="file" id="contentFile" accept="image/*" />
    </label>
    */}
    <label>Level
      <select id="level" name="level" required>
        <option value="초급">초급</option>
        <option value="중급">중급</option>
        <option value="고급">고급</option>
      </select>
    </label>
    <button type="submit" id="submit-btn">
      <span class="button-text">Submit</span>
      <span id="submit-spinner" class="spinner"></span>
    </button>
  </form>

  <div id="result"></div>

  <script>
    // Using marked.js for Markdown rendering
    // Ensure you include <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script> in head or body
    // Example CDN link: https://cdn.jsdelivr.net/npm/marked/marked.min.js

    const WORKER_URL = 'https://writing-feedback-app.sehyunglee2015.workers.dev'; // <-- **실제 Worker URL로 변경**

    const form = document.getElementById("feedback-form");
    const resultDiv = document.getElementById("result");
    const submitBtn = document.getElementById("submit-btn");
    const submitSpinner = document.getElementById("submit-spinner");

    form.addEventListener("submit", async (e) => {
      e.preventDefault();

      // --- Show Submit Spinner ---
      submitBtn.disabled = true;
      submitSpinner.style.display = "inline-block"; // Explicitly show spinner (CSS handles display: none when not disabled)
      resultDiv.innerHTML = ''; // Clear previous results
      resultDiv.classList.remove('hidden'); // Ensure result area is visible if it was hidden


      // gather inputs
      const topic = document.getElementById("topic").value;
      const keywords = document.getElementById("keywords").value;
      const contentText = document.getElementById("contentText").value;
      // Assuming image upload is handled server-side or omitted for simplicity here
      // const fileInput = document.getElementById("contentFile");
      // let contentPayload = contentText;
      // if (fileInput.files.length) {
      //   contentPayload = await new Promise(resolve => {
      //     const reader = new FileReader();
      //     reader.onload = () => resolve(reader.result);
      //     reader.readAsDataURL(fileInput.files[0]); // Reads file as Data URL (Base64)
      //   });
      // }


      try {
        // request feedback
        const res = await fetch(`${WORKER_URL}/api/feedback`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            topic,
            keywords,
            // Send text content. If image upload is needed, the Worker must handle the base64 string or file.
            content: contentText, // Use 'content' matching Worker expectation
            level: document.getElementById("level").value
          })
        });

        const data = await res.json();

        if (!res.ok) {
          // Handle HTTP errors from Worker
          resultDiv.innerHTML = `
            <p style="color:red;">
              Error ${res.status}: ${data.error || JSON.stringify(data)}
            </p>`;
          return; // Stop here on error
        }

        // --- Success: Display results ---
        // Assuming Worker returns { feedback, modelAnswer } on success
        const { feedback, modelAnswer } = data; // Use 'data' which is the parsed JSON


        resultDiv.innerHTML = `
          <div class="box">
            <h3>Feedback</h3>
            <div id="feedback-content">${marked.parse(feedback || '')}</div>
          </div>

          <div class="box" id="model-answer-box">
            <h3>Model Answer</h3>
            <div id="model-answer-content" class="model-box">${marked.parse(modelAnswer || '')}</div>
          </div>

          <div style="margin-top: 1rem;">
            <button id="tts-btn">
                <span class="button-text">Generate TTS</span>
                <span id="tts-spinner" class="spinner"></span> {/* Added spinner for TTS button */}
            </button>
            <audio id="tts-audio" controls style="display:none; margin-left: 1rem; vertical-align: middle;"></audio>
            <a id="download-link" style="display:none; margin-top:1rem; margin-left: 1rem; vertical-align: middle;">Download Audio</a>
          </div>

            {/* Add Print Button back if needed, with its spinner */}
            <button id="print-btn" style="margin-top: 1rem;">
                 <span class="button-text">Print</span>
                 <span id="print-spinner" class="spinner"></span> {/* Added spinner for Print button */}
            </button>
        `;

        // --- Add Event Listeners to Dynamically Created Buttons ---

        // TTS handler
        const ttsBtn = document.getElementById('tts-btn');
        const ttsSpinner = document.getElementById('tts-spinner'); // Get TTS spinner
        const audioEl = document.getElementById('tts-audio');
        const downloadLink = document.getElementById('download-link');


        ttsBtn.addEventListener("click", async () => {
            // --- Show TTS Spinner ---
            ttsBtn.disabled = true;
            ttsSpinner.style.display = "inline-block"; // Show TTS spinner

            audioEl.style.display = 'none'; // Hide previous audio
            downloadLink.style.display = 'none'; // Hide previous download link


            try {
                const ttsRes = await fetch(`${WORKER_URL}/api/tts`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ text: modelAnswer }) // Use modelAnswer from the main fetch scope
                });

                if (!ttsRes.ok) {
                    // Handle TTS API errors
                    console.error("TTS API Error:", ttsRes.status);
                    const ttsErrorDiv = document.createElement('div');
                    ttsErrorDiv.style.color = 'orange';
                    ttsErrorDiv.textContent = 'Failed to generate audio. Please check console for details.';
                    ttsPlayerDiv.appendChild(ttsErrorDiv);
                    // Don't return, still hide spinner and re-enable button
                } else {
                    // Success: Play/Download TTS
                    const blob = await ttsRes.blob();
                    const url = URL.createObjectURL(blob);

                    audioEl.src = url;
                    audioEl.style.display = 'block'; // Show audio player

                    downloadLink.href = url;
                    downloadLink.download = 'model-answer.mp3';
                    downloadLink.style.display = 'inline-block'; // Show download link
                }

            } catch(ttsError) {
                 // Handle network or unexpected errors during TTS fetch
                 console.error("TTS Fetch Error:", ttsError);
                 const ttsErrorDiv = document.createElement('div');
                 ttsErrorDiv.style.color = 'orange';
                 ttsErrorDiv.textContent = 'An unexpected error occurred during audio generation.';
                 ttsPlayerDiv.appendChild(ttsErrorDiv);
            } finally {
                // --- Hide TTS Spinner ---
                 ttsSpinner.style.display = "none"; // Hide TTS spinner
                ttsBtn.disabled = false; // Re-enable TTS button
            }

        });

        // Print handler with spinner (matching the dynamic creation)
         const printBtn = document.getElementById("print-btn");
         const printSpinner = document.getElementById("print-spinner");

        document.getElementById("print-btn").addEventListener("click", () => {
            // --- Show Print Spinner ---
            printBtn.disabled = true;
            printSpinner.style.display = "inline-block"; // Show Print spinner

            // Note: window.print() is synchronous and blocks. The spinner
            // might only show briefly or not at all before the print dialog appears.
            // Re-enabling after print initiation is not perfect but matches the pattern.
            // A more complex solution involves postMessage from the print window.

            const w = window.open(
              "",
              "_blank",
              `width=${screen.availWidth},height=${screen.availHeight}`
            );
            w.document.write(`
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>샘플 예문 인쇄</title>
  <style>
    body { font-family: sans-serif; padding: 2rem; }
    .model-box { text-align: left; font-size: 1.2em; line-height: 1.5; }
    .model-box h3 { text-align: center; margin-top: 0; }
    @media print { button { display: none; } }
  </style>
</head>
<body>
  ${document.getElementById("model-answer-box").outerHTML}
  <script>
    // This function runs in the popup window AFTER the print dialog is closed or cancelled
    window.onafterprint = function() {
        // You could potentially use postMessage here to signal the main window
        // window.opener.postMessage('printFinished', 'https://sayhyoung.github.io'); // Example
        window.close(); // Close the popup window
    };
    window.print(); // Open the print dialog
  <\/script>
</body>
</html>
            `);
            w.document.close();

            // --- Hide Print Spinner ---
            // This hides the spinner right after initiating print.
            // It won't spin during the print dialog unless you add more complex logic.
            printSpinner.style.display = "none"; // Hide Print spinner
            printBtn.disabled = false; // Re-enable Print button
        });


      } catch (error) {
        // Handle network errors during the main fetch
        console.error("Main Fetch Error:", error);
        resultDiv.innerHTML = `
          <p style="color:red;">
            An unexpected error occurred: ${error.message}
          </p>`;
      } finally {
        // --- Hide Submit Spinner (always runs after try/catch) ---
        submitSpinner.style.display = "none"; // Hide Submit spinner
        submitBtn.disabled = false; // Re-enable Submit button
      }
    });
  </script>
  {/* Add marked.js CDN if not already in head */}
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</body>
</html>
